services:
  api:
    build:
      context: .
    container_name: garage_api
    env_file:
      - .env
    environment:
      APP_ENV: ${APP_ENV:-production}
      SECRET_KEY: ${SECRET_KEY:-changeme-in-prod}
      DATABASE_URL: ${DATABASE_URL}
      UPLOADS_DIR: /app/uploads
    # não exponha a API publicamente; só interno
    expose:
      - "8000"
    volumes:
      - ./uploads:/app/uploads
    restart: unless-stopped

  scheduler:
    build:
      context: .
    container_name: garage_scheduler
    env_file:
      - .env
    environment:
      # usa o nome do serviço "api" dentro da rede do compose
      API_BASE_URL: ${API_BASE_URL:-http://api:8000}
      APP_ENV: ${APP_ENV:-production}
      DATABASE_URL: ${DATABASE_URL}
      SECRET_KEY: ${SECRET_KEY:-changeme-in-prod}
    depends_on:
      api:
        condition: service_started
    restart: unless-stopped
    command: ["./docker/scheduler.sh"]

  frontend:
    build:
      context: ./frontend
      args:
        # same-origin via /api (vai ser proxy no Nginx)
        VITE_API_BASE_URL: ${FRONTEND_API_BASE_URL:-/api}
    container_name: garage_frontend
    # publicar para a internet
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - api
    volumes:
      # aponto pro arquivo de config do Nginx
      - ./frontend/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # volumes de certificados e webroot do ACME
      - letsencrypt:/etc/letsencrypt:ro
      - certbot-www:/var/www/certbot:ro
    restart: unless-stopped

  # container para emitir/renovar certificados
  certbot:
    image: certbot/certbot
    container_name: garage_certbot
    volumes:
      - letsencrypt:/etc/letsencrypt
      - certbot-www:/var/www/certbot
    # não precisa rodar em daemon; usaremos `docker compose run`

volumes:
  letsencrypt:
  certbot-www:
